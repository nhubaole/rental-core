// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: return_request.sql

package dataaccess

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const approveReturnRequest = `-- name: ApproveReturnRequest :exec
UPDATE public.return_requests
SET status = $1,
    updated_at= now()
WHERE deleted_at IS NULL
    AND id = $2
`

type ApproveReturnRequestParams struct {
	Status *int32 `json:"status"`
	ID     int32  `json:"id"`
}

func (q *Queries) ApproveReturnRequest(ctx context.Context, arg ApproveReturnRequestParams) error {
	_, err := q.db.Exec(ctx, approveReturnRequest, arg.Status, arg.ID)
	return err
}

const createReturnRequest = `-- name: CreateReturnRequest :one
INSERT INTO public.return_requests
    (contract_id, --1
     reason, --2
     return_date, --3 
     deduct_amount, --5 
     total_return_deposit, --6 
     created_user, --7
     status, --4
     created_at,
     updated_at)
VALUES(
    $1, $2, $3, $4, $5, $6, 0, now(), now()
    ) RETURNING id
`

type CreateReturnRequestParams struct {
	ContractID         *int32           `json:"contract_id"`
	Reason             *string          `json:"reason"`
	ReturnDate         pgtype.Timestamp `json:"return_date"`
	DeductAmount       *float64         `json:"deduct_amount"`
	TotalReturnDeposit *float64         `json:"total_return_deposit"`
	CreatedUser        *int32           `json:"created_user"`
}

func (q *Queries) CreateReturnRequest(ctx context.Context, arg CreateReturnRequestParams) (int32, error) {
	row := q.db.QueryRow(ctx, createReturnRequest,
		arg.ContractID,
		arg.Reason,
		arg.ReturnDate,
		arg.DeductAmount,
		arg.TotalReturnDeposit,
		arg.CreatedUser,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const getReturnRequestByID = `-- name: GetReturnRequestByID :one
SELECT rr.id, rr.reason,c.id as contract_id, c.room_id, rr.return_date, rr.status, rr.deduct_amount, rr.total_return_deposit, rr.created_user, rr.created_at, rr.updated_at
FROM public.return_requests rr 
LEFT JOIN public.contracts c
ON rr.contract_id = c.id
WHERE deleted_at IS NULL
    AND rr.id = $1
`

type GetReturnRequestByIDRow struct {
	ID                 int32            `json:"id"`
	Reason             *string          `json:"reason"`
	ContractID         *int32           `json:"contract_id"`
	RoomID             *int32           `json:"room_id"`
	ReturnDate         pgtype.Timestamp `json:"return_date"`
	Status             *int32           `json:"status"`
	DeductAmount       *float64         `json:"deduct_amount"`
	TotalReturnDeposit *float64         `json:"total_return_deposit"`
	CreatedUser        *int32           `json:"created_user"`
	CreatedAt          pgtype.Timestamp `json:"created_at"`
	UpdatedAt          pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) GetReturnRequestByID(ctx context.Context, id int32) (GetReturnRequestByIDRow, error) {
	row := q.db.QueryRow(ctx, getReturnRequestByID, id)
	var i GetReturnRequestByIDRow
	err := row.Scan(
		&i.ID,
		&i.Reason,
		&i.ContractID,
		&i.RoomID,
		&i.ReturnDate,
		&i.Status,
		&i.DeductAmount,
		&i.TotalReturnDeposit,
		&i.CreatedUser,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getReturnRequestByLandlordID = `-- name: GetReturnRequestByLandlordID :many
SELECT rr.id, rr.contract_id, r.id as room_id, rr.reason, rr.return_date, rr.status, rr.deduct_amount, rr.total_return_deposit, rr.created_user, rr.created_at, rr.updated_at
FROM public.return_requests rr LEFT JOIN public.contracts c
ON rr.contract_id = c.id
LEFT JOIN public.rooms r ON c.room_id = r.id
WHERE r.owner = $1
`

type GetReturnRequestByLandlordIDRow struct {
	ID                 int32            `json:"id"`
	ContractID         *int32           `json:"contract_id"`
	RoomID             *int32           `json:"room_id"`
	Reason             *string          `json:"reason"`
	ReturnDate         pgtype.Timestamp `json:"return_date"`
	Status             *int32           `json:"status"`
	DeductAmount       *float64         `json:"deduct_amount"`
	TotalReturnDeposit *float64         `json:"total_return_deposit"`
	CreatedUser        *int32           `json:"created_user"`
	CreatedAt          pgtype.Timestamp `json:"created_at"`
	UpdatedAt          pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) GetReturnRequestByLandlordID(ctx context.Context, owner int32) ([]GetReturnRequestByLandlordIDRow, error) {
	rows, err := q.db.Query(ctx, getReturnRequestByLandlordID, owner)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReturnRequestByLandlordIDRow
	for rows.Next() {
		var i GetReturnRequestByLandlordIDRow
		if err := rows.Scan(
			&i.ID,
			&i.ContractID,
			&i.RoomID,
			&i.Reason,
			&i.ReturnDate,
			&i.Status,
			&i.DeductAmount,
			&i.TotalReturnDeposit,
			&i.CreatedUser,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
