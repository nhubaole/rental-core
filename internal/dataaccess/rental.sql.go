// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: rental.sql

package dataaccess

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkRequestExisted = `-- name: CheckRequestExisted :one
SELECT status , deleted_at
FROM PUBLIC.RENTAL_REQUESTS 
WHERE room_id = $1 and sender_id = $2
`

type CheckRequestExistedParams struct {
	RoomID   int32 `json:"room_id"`
	SenderID int32 `json:"sender_id"`
}

type CheckRequestExistedRow struct {
	Status    int32              `json:"status"`
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
}

func (q *Queries) CheckRequestExisted(ctx context.Context, arg CheckRequestExistedParams) (CheckRequestExistedRow, error) {
	row := q.db.QueryRow(ctx, checkRequestExisted, arg.RoomID, arg.SenderID)
	var i CheckRequestExistedRow
	err := row.Scan(&i.Status, &i.DeletedAt)
	return i, err
}

const createRentalRequest = `-- name: CreateRentalRequest :one
INSERT INTO PUBLIC.RENTAL_REQUESTS
(
    code,
    sender_id,
    room_id,
    suggested_price,
    num_of_person,
    begin_date,
    end_date,
    addition_request,
    status,
    created_at,
    updated_at
) VALUES
(
    $1, $2, $3, $4, $5, $6, $7, $8, $9, now(), now()
)
RETURNING id, code, sender_id, room_id, suggested_price, num_of_person, begin_date, end_date,     addition_request, status, created_at
`

type CreateRentalRequestParams struct {
	Code            string             `json:"code"`
	SenderID        int32              `json:"sender_id"`
	RoomID          int32              `json:"room_id"`
	SuggestedPrice  *float64           `json:"suggested_price"`
	NumOfPerson     *int32             `json:"num_of_person"`
	BeginDate       pgtype.Timestamptz `json:"begin_date"`
	EndDate         pgtype.Timestamptz `json:"end_date"`
	AdditionRequest *string            `json:"addition_request"`
	Status          int32              `json:"status"`
}

type CreateRentalRequestRow struct {
	ID              int32              `json:"id"`
	Code            string             `json:"code"`
	SenderID        int32              `json:"sender_id"`
	RoomID          int32              `json:"room_id"`
	SuggestedPrice  *float64           `json:"suggested_price"`
	NumOfPerson     *int32             `json:"num_of_person"`
	BeginDate       pgtype.Timestamptz `json:"begin_date"`
	EndDate         pgtype.Timestamptz `json:"end_date"`
	AdditionRequest *string            `json:"addition_request"`
	Status          int32              `json:"status"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) CreateRentalRequest(ctx context.Context, arg CreateRentalRequestParams) (CreateRentalRequestRow, error) {
	row := q.db.QueryRow(ctx, createRentalRequest,
		arg.Code,
		arg.SenderID,
		arg.RoomID,
		arg.SuggestedPrice,
		arg.NumOfPerson,
		arg.BeginDate,
		arg.EndDate,
		arg.AdditionRequest,
		arg.Status,
	)
	var i CreateRentalRequestRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.SenderID,
		&i.RoomID,
		&i.SuggestedPrice,
		&i.NumOfPerson,
		&i.BeginDate,
		&i.EndDate,
		&i.AdditionRequest,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const deleteRequest = `-- name: DeleteRequest :exec
UPDATE public.rental_requests
SET deleted_at = now()
WHERE id = $1
`

func (q *Queries) DeleteRequest(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteRequest, id)
	return err
}

const getRentalRequestSuccessByRoomId = `-- name: GetRentalRequestSuccessByRoomId :one
SELECT id, code, sender_id, room_id, suggested_price, num_of_person, begin_date, end_date, addition_request, status, created_at, updated_at, deleted_at
FROM public.rental_requests
WHERE room_id = $1
  AND status = 2
  AND begin_date <= now()
  AND end_date >= now()
`

func (q *Queries) GetRentalRequestSuccessByRoomId(ctx context.Context, roomID int32) (RentalRequest, error) {
	row := q.db.QueryRow(ctx, getRentalRequestSuccessByRoomId, roomID)
	var i RentalRequest
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.SenderID,
		&i.RoomID,
		&i.SuggestedPrice,
		&i.NumOfPerson,
		&i.BeginDate,
		&i.EndDate,
		&i.AdditionRequest,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getRequestByID = `-- name: GetRequestByID :one
SELECT id, code, sender_id, room_id, suggested_price, num_of_person, begin_date, end_date, addition_request, status, created_at, updated_at, deleted_at
FROM PUBLIC.RENTAL_REQUESTS 
WHERE id = $1 and deleted_at is null
`

func (q *Queries) GetRequestByID(ctx context.Context, id int32) (RentalRequest, error) {
	row := q.db.QueryRow(ctx, getRequestByID, id)
	var i RentalRequest
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.SenderID,
		&i.RoomID,
		&i.SuggestedPrice,
		&i.NumOfPerson,
		&i.BeginDate,
		&i.EndDate,
		&i.AdditionRequest,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getRequestByOwnerID = `-- name: GetRequestByOwnerID :many
SELECT     
    RR.id,
    RR.code,
    RR.sender_id,
    RR.room_id,
    RR.suggested_price,
    RR.num_of_person,
    RR.begin_date,
    RR.end_date,
    RR.addition_request,
    RR.status,
    RR.created_at,
    RR.updated_at
FROM PUBLIC.RENTAL_REQUESTS  RR left join PUBLIC.ROOMS r
	on RR.room_id = r.id
WHERE r.owner = $1 
	and RR.deleted_at is NULL
`

type GetRequestByOwnerIDRow struct {
	ID              int32              `json:"id"`
	Code            string             `json:"code"`
	SenderID        int32              `json:"sender_id"`
	RoomID          int32              `json:"room_id"`
	SuggestedPrice  *float64           `json:"suggested_price"`
	NumOfPerson     *int32             `json:"num_of_person"`
	BeginDate       pgtype.Timestamptz `json:"begin_date"`
	EndDate         pgtype.Timestamptz `json:"end_date"`
	AdditionRequest *string            `json:"addition_request"`
	Status          int32              `json:"status"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetRequestByOwnerID(ctx context.Context, owner int32) ([]GetRequestByOwnerIDRow, error) {
	rows, err := q.db.Query(ctx, getRequestByOwnerID, owner)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRequestByOwnerIDRow
	for rows.Next() {
		var i GetRequestByOwnerIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.SenderID,
			&i.RoomID,
			&i.SuggestedPrice,
			&i.NumOfPerson,
			&i.BeginDate,
			&i.EndDate,
			&i.AdditionRequest,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestByRoomID = `-- name: GetRequestByRoomID :many
SELECT     
    RR.id,
    RR.code,
    RR.sender_id,
    RR.room_id,
    RR.suggested_price,
    RR.num_of_person,
    RR.begin_date,
    RR.end_date,
    RR.addition_request,
    RR.status,
    RR.created_at,
    RR.updated_at
FROM PUBLIC.RENTAL_REQUESTS  RR 
WHERE RR.room_id = $1
	and RR.deleted_at is NULL
`

type GetRequestByRoomIDRow struct {
	ID              int32              `json:"id"`
	Code            string             `json:"code"`
	SenderID        int32              `json:"sender_id"`
	RoomID          int32              `json:"room_id"`
	SuggestedPrice  *float64           `json:"suggested_price"`
	NumOfPerson     *int32             `json:"num_of_person"`
	BeginDate       pgtype.Timestamptz `json:"begin_date"`
	EndDate         pgtype.Timestamptz `json:"end_date"`
	AdditionRequest *string            `json:"addition_request"`
	Status          int32              `json:"status"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetRequestByRoomID(ctx context.Context, roomID int32) ([]GetRequestByRoomIDRow, error) {
	rows, err := q.db.Query(ctx, getRequestByRoomID, roomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRequestByRoomIDRow
	for rows.Next() {
		var i GetRequestByRoomIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.SenderID,
			&i.RoomID,
			&i.SuggestedPrice,
			&i.NumOfPerson,
			&i.BeginDate,
			&i.EndDate,
			&i.AdditionRequest,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestBySenderID = `-- name: GetRequestBySenderID :many
SELECT 
    RR.id,
    RR.code,
    RR.sender_id,
    RR.room_id,
    RR.suggested_price,
    RR.num_of_person,
    RR.begin_date,
    RR.end_date,
    RR.addition_request,
    RR.status,
    RR.created_at,
    RR.updated_at
FROM PUBLIC.RENTAL_REQUESTS  RR
WHERE sender_id = $1
    AND RR.deleted_at is NULL
`

type GetRequestBySenderIDRow struct {
	ID              int32              `json:"id"`
	Code            string             `json:"code"`
	SenderID        int32              `json:"sender_id"`
	RoomID          int32              `json:"room_id"`
	SuggestedPrice  *float64           `json:"suggested_price"`
	NumOfPerson     *int32             `json:"num_of_person"`
	BeginDate       pgtype.Timestamptz `json:"begin_date"`
	EndDate         pgtype.Timestamptz `json:"end_date"`
	AdditionRequest *string            `json:"addition_request"`
	Status          int32              `json:"status"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetRequestBySenderID(ctx context.Context, senderID int32) ([]GetRequestBySenderIDRow, error) {
	rows, err := q.db.Query(ctx, getRequestBySenderID, senderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRequestBySenderIDRow
	for rows.Next() {
		var i GetRequestBySenderIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.SenderID,
			&i.RoomID,
			&i.SuggestedPrice,
			&i.NumOfPerson,
			&i.BeginDate,
			&i.EndDate,
			&i.AdditionRequest,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRequestStatusById = `-- name: UpdateRequestStatusById :exec
update PUBLIC.RENTAL_REQUESTS
set status = $1 WHERE id = $2 and status = 1
`

type UpdateRequestStatusByIdParams struct {
	Status int32 `json:"status"`
	ID     int32 `json:"id"`
}

func (q *Queries) UpdateRequestStatusById(ctx context.Context, arg UpdateRequestStatusByIdParams) error {
	_, err := q.db.Exec(ctx, updateRequestStatusById, arg.Status, arg.ID)
	return err
}
