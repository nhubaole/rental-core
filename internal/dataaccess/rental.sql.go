// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: rental.sql

package dataaccess

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkRequestExisted = `-- name: CheckRequestExisted :one
SELECT status , deleted_at
FROM PUBLIC.RENTAL_REQUESTS 
WHERE room_id = $1 and sender_id = $2
`

type CheckRequestExistedParams struct {
	RoomID   int32 `json:"room_id"`
	SenderID int32 `json:"sender_id"`
}

type CheckRequestExistedRow struct {
	Status    int32              `json:"status"`
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
}

func (q *Queries) CheckRequestExisted(ctx context.Context, arg CheckRequestExistedParams) (CheckRequestExistedRow, error) {
	row := q.db.QueryRow(ctx, checkRequestExisted, arg.RoomID, arg.SenderID)
	var i CheckRequestExistedRow
	err := row.Scan(&i.Status, &i.DeletedAt)
	return i, err
}

const createRentalRequest = `-- name: CreateRentalRequest :one
INSERT INTO PUBLIC.RENTAL_REQUESTS
(
    code,
    sender_id,
    room_id,
    suggested_price,
    num_of_person,
    begin_date,
    end_date,
    addition_request,
    status,
    created_at,
    updated_at
) VALUES
(
    $1, $2, $3, $4, $5, $6, $7, $8, $9, now(), now()
)
RETURNING id, code, sender_id, room_id, suggested_price, num_of_person, begin_date, end_date,     addition_request, status, created_at
`

type CreateRentalRequestParams struct {
	Code            string             `json:"code"`
	SenderID        int32              `json:"sender_id"`
	RoomID          int32              `json:"room_id"`
	SuggestedPrice  *float64           `json:"suggested_price"`
	NumOfPerson     *int32             `json:"num_of_person"`
	BeginDate       pgtype.Timestamptz `json:"begin_date"`
	EndDate         pgtype.Timestamptz `json:"end_date"`
	AdditionRequest *string            `json:"addition_request"`
	Status          int32              `json:"status"`
}

type CreateRentalRequestRow struct {
	ID              int32              `json:"id"`
	Code            string             `json:"code"`
	SenderID        int32              `json:"sender_id"`
	RoomID          int32              `json:"room_id"`
	SuggestedPrice  *float64           `json:"suggested_price"`
	NumOfPerson     *int32             `json:"num_of_person"`
	BeginDate       pgtype.Timestamptz `json:"begin_date"`
	EndDate         pgtype.Timestamptz `json:"end_date"`
	AdditionRequest *string            `json:"addition_request"`
	Status          int32              `json:"status"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) CreateRentalRequest(ctx context.Context, arg CreateRentalRequestParams) (CreateRentalRequestRow, error) {
	row := q.db.QueryRow(ctx, createRentalRequest,
		arg.Code,
		arg.SenderID,
		arg.RoomID,
		arg.SuggestedPrice,
		arg.NumOfPerson,
		arg.BeginDate,
		arg.EndDate,
		arg.AdditionRequest,
		arg.Status,
	)
	var i CreateRentalRequestRow
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.SenderID,
		&i.RoomID,
		&i.SuggestedPrice,
		&i.NumOfPerson,
		&i.BeginDate,
		&i.EndDate,
		&i.AdditionRequest,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const deleteRequest = `-- name: DeleteRequest :exec
UPDATE public.rental_requests
SET deleted_at = now()
WHERE id = $1
`

func (q *Queries) DeleteRequest(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteRequest, id)
	return err
}

const getRentalRequestSuccessByRoomId = `-- name: GetRentalRequestSuccessByRoomId :one
SELECT id, code, sender_id, room_id, suggested_price, num_of_person, begin_date, end_date, addition_request, status, created_at, updated_at, deleted_at
FROM public.rental_requests
WHERE room_id = $1
  AND status = 2
  AND begin_date <= now()
  AND end_date >= now()
`

func (q *Queries) GetRentalRequestSuccessByRoomId(ctx context.Context, roomID int32) (RentalRequest, error) {
	row := q.db.QueryRow(ctx, getRentalRequestSuccessByRoomId, roomID)
	var i RentalRequest
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.SenderID,
		&i.RoomID,
		&i.SuggestedPrice,
		&i.NumOfPerson,
		&i.BeginDate,
		&i.EndDate,
		&i.AdditionRequest,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getRequestByID = `-- name: GetRequestByID :one
SELECT id, code, sender_id, room_id, suggested_price, num_of_person, begin_date, end_date, addition_request, status, created_at, updated_at, deleted_at
FROM PUBLIC.RENTAL_REQUESTS 
WHERE id = $1 and deleted_at is null
`

func (q *Queries) GetRequestByID(ctx context.Context, id int32) (RentalRequest, error) {
	row := q.db.QueryRow(ctx, getRequestByID, id)
	var i RentalRequest
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.SenderID,
		&i.RoomID,
		&i.SuggestedPrice,
		&i.NumOfPerson,
		&i.BeginDate,
		&i.EndDate,
		&i.AdditionRequest,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getRequestByOwnerID = `-- name: GetRequestByOwnerID :many
SELECT 
    r.id AS room_id,
    COUNT(RR.id) AS request_count,
    JSON_AGG(
        JSON_BUILD_OBJECT(
            'id', RR.id,
            'avatar', u.avatar_url,
            'name', u.full_name,
            'status', RR.status,
            'created_at', RR.created_at
        )
    )::text AS request_info
FROM PUBLIC.RENTAL_REQUESTS RR
LEFT JOIN PUBLIC.ROOMS r
    ON RR.room_id = r.id
LEFT JOIN PUBLIC.USERS u
    ON RR.sender_id = u.id
WHERE r.owner = $1
    AND RR.deleted_at IS NULL
GROUP BY r.id
`

type GetRequestByOwnerIDRow struct {
	RoomID       *int32 `json:"room_id"`
	RequestCount int64  `json:"request_count"`
	RequestInfo  string `json:"request_info"`
}

func (q *Queries) GetRequestByOwnerID(ctx context.Context, owner int32) ([]GetRequestByOwnerIDRow, error) {
	rows, err := q.db.Query(ctx, getRequestByOwnerID, owner)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRequestByOwnerIDRow
	for rows.Next() {
		var i GetRequestByOwnerIDRow
		if err := rows.Scan(&i.RoomID, &i.RequestCount, &i.RequestInfo); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestByOwnerIDForProccessTracking = `-- name: GetRequestByOwnerIDForProccessTracking :many
SELECT rr.id, code, sender_id, room_id, suggested_price, num_of_person, begin_date, end_date, addition_request, rr.status, rr.created_at, rr.updated_at, rr.deleted_at, r.id, title, address, room_number, room_images, utilities, description, room_type, owner, capacity, gender, area, total_price, deposit, electricity_cost, water_cost, internet_cost, is_parking, parking_fee, r.status, is_rent, r.created_at, r.updated_at, r.deleted_at, available_from
FROM PUBLIC.RENTAL_REQUESTS rr
LEFT JOIN public.rooms r ON rr.room_id = r.id
WHERE r.owner = $1 and rr.deleted_at is null
`

type GetRequestByOwnerIDForProccessTrackingRow struct {
	ID              int32              `json:"id"`
	Code            string             `json:"code"`
	SenderID        int32              `json:"sender_id"`
	RoomID          int32              `json:"room_id"`
	SuggestedPrice  *float64           `json:"suggested_price"`
	NumOfPerson     *int32             `json:"num_of_person"`
	BeginDate       pgtype.Timestamptz `json:"begin_date"`
	EndDate         pgtype.Timestamptz `json:"end_date"`
	AdditionRequest *string            `json:"addition_request"`
	Status          int32              `json:"status"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	DeletedAt       pgtype.Timestamptz `json:"deleted_at"`
	ID_2            *int32             `json:"id_2"`
	Title           *string            `json:"title"`
	Address         []string           `json:"address"`
	RoomNumber      *int32             `json:"room_number"`
	RoomImages      []string           `json:"room_images"`
	Utilities       []string           `json:"utilities"`
	Description     *string            `json:"description"`
	RoomType        *string            `json:"room_type"`
	Owner           *int32             `json:"owner"`
	Capacity        *int32             `json:"capacity"`
	Gender          *int32             `json:"gender"`
	Area            *float64           `json:"area"`
	TotalPrice      *float64           `json:"total_price"`
	Deposit         *float64           `json:"deposit"`
	ElectricityCost *float64           `json:"electricity_cost"`
	WaterCost       *float64           `json:"water_cost"`
	InternetCost    *float64           `json:"internet_cost"`
	IsParking       *bool              `json:"is_parking"`
	ParkingFee      *float64           `json:"parking_fee"`
	Status_2        *int32             `json:"status_2"`
	IsRent          *bool              `json:"is_rent"`
	CreatedAt_2     pgtype.Timestamptz `json:"created_at_2"`
	UpdatedAt_2     pgtype.Timestamptz `json:"updated_at_2"`
	DeletedAt_2     pgtype.Timestamptz `json:"deleted_at_2"`
	AvailableFrom   pgtype.Timestamptz `json:"available_from"`
}

func (q *Queries) GetRequestByOwnerIDForProccessTracking(ctx context.Context, owner int32) ([]GetRequestByOwnerIDForProccessTrackingRow, error) {
	rows, err := q.db.Query(ctx, getRequestByOwnerIDForProccessTracking, owner)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRequestByOwnerIDForProccessTrackingRow
	for rows.Next() {
		var i GetRequestByOwnerIDForProccessTrackingRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.SenderID,
			&i.RoomID,
			&i.SuggestedPrice,
			&i.NumOfPerson,
			&i.BeginDate,
			&i.EndDate,
			&i.AdditionRequest,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ID_2,
			&i.Title,
			&i.Address,
			&i.RoomNumber,
			&i.RoomImages,
			&i.Utilities,
			&i.Description,
			&i.RoomType,
			&i.Owner,
			&i.Capacity,
			&i.Gender,
			&i.Area,
			&i.TotalPrice,
			&i.Deposit,
			&i.ElectricityCost,
			&i.WaterCost,
			&i.InternetCost,
			&i.IsParking,
			&i.ParkingFee,
			&i.Status_2,
			&i.IsRent,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
			&i.DeletedAt_2,
			&i.AvailableFrom,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestByRoomID = `-- name: GetRequestByRoomID :many
SELECT     
    RR.id,
    RR.code,
    RR.sender_id,
    RR.room_id,
    RR.suggested_price,
    RR.num_of_person,
    RR.begin_date,
    RR.end_date,
    RR.addition_request,
    RR.status,
    RR.created_at,
    RR.updated_at
FROM PUBLIC.RENTAL_REQUESTS  RR 
WHERE RR.room_id = $1
	and RR.deleted_at is NULL
`

type GetRequestByRoomIDRow struct {
	ID              int32              `json:"id"`
	Code            string             `json:"code"`
	SenderID        int32              `json:"sender_id"`
	RoomID          int32              `json:"room_id"`
	SuggestedPrice  *float64           `json:"suggested_price"`
	NumOfPerson     *int32             `json:"num_of_person"`
	BeginDate       pgtype.Timestamptz `json:"begin_date"`
	EndDate         pgtype.Timestamptz `json:"end_date"`
	AdditionRequest *string            `json:"addition_request"`
	Status          int32              `json:"status"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetRequestByRoomID(ctx context.Context, roomID int32) ([]GetRequestByRoomIDRow, error) {
	rows, err := q.db.Query(ctx, getRequestByRoomID, roomID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRequestByRoomIDRow
	for rows.Next() {
		var i GetRequestByRoomIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.SenderID,
			&i.RoomID,
			&i.SuggestedPrice,
			&i.NumOfPerson,
			&i.BeginDate,
			&i.EndDate,
			&i.AdditionRequest,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestBySenderID = `-- name: GetRequestBySenderID :many
SELECT 
    r.id AS room_id,
    COUNT(RR.id) AS request_count,
    JSON_AGG(
        JSON_BUILD_OBJECT(
            'id', RR.id,
            'avatar', u.avatar_url,
            'name', u.full_name,
            'status', RR.status,
            'created_at', RR.created_at
        )
    )::text AS request_info
FROM PUBLIC.RENTAL_REQUESTS RR
LEFT JOIN PUBLIC.ROOMS r
    ON RR.room_id = r.id
LEFT JOIN PUBLIC.USERS u
    ON RR.sender_id = u.id
WHERE RR.sender_id = $1
    AND RR.deleted_at IS NULL
GROUP BY r.id
`

type GetRequestBySenderIDRow struct {
	RoomID       *int32 `json:"room_id"`
	RequestCount int64  `json:"request_count"`
	RequestInfo  string `json:"request_info"`
}

func (q *Queries) GetRequestBySenderID(ctx context.Context, senderID int32) ([]GetRequestBySenderIDRow, error) {
	rows, err := q.db.Query(ctx, getRequestBySenderID, senderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRequestBySenderIDRow
	for rows.Next() {
		var i GetRequestBySenderIDRow
		if err := rows.Scan(&i.RoomID, &i.RequestCount, &i.RequestInfo); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRequestBySenderIDForProccessTracking = `-- name: GetRequestBySenderIDForProccessTracking :many
SELECT id, code, sender_id, room_id, suggested_price, num_of_person, begin_date, end_date, addition_request, status, created_at, updated_at, deleted_at
FROM PUBLIC.RENTAL_REQUESTS 
WHERE sender_id = $1 and deleted_at is null
`

func (q *Queries) GetRequestBySenderIDForProccessTracking(ctx context.Context, senderID int32) ([]RentalRequest, error) {
	rows, err := q.db.Query(ctx, getRequestBySenderIDForProccessTracking, senderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RentalRequest
	for rows.Next() {
		var i RentalRequest
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.SenderID,
			&i.RoomID,
			&i.SuggestedPrice,
			&i.NumOfPerson,
			&i.BeginDate,
			&i.EndDate,
			&i.AdditionRequest,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRequestStatusById = `-- name: UpdateRequestStatusById :exec
update PUBLIC.RENTAL_REQUESTS
set status = $1 WHERE id = $2 and status = 1
`

type UpdateRequestStatusByIdParams struct {
	Status int32 `json:"status"`
	ID     int32 `json:"id"`
}

func (q *Queries) UpdateRequestStatusById(ctx context.Context, arg UpdateRequestStatusByIdParams) error {
	_, err := q.db.Exec(ctx, updateRequestStatusById, arg.Status, arg.ID)
	return err
}
